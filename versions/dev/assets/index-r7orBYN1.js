import{z as e}from"./main-BQiiYDFW.js";var r={};Object.defineProperty(r,"__esModule",{value:!0});var t=r.ImportUtil=void 0;function o(e,r,t){if(e){let r=e.replace(/[^a-zA-Z_]([a-z])/g,((e,r)=>r.toUpperCase()));return r=r.replace(/[^a-zA-Z_]/g,""),r}return"default"===r||"*"===r?null!=t?t:"a":r}function i(e){return(null==e?void 0:e.isIdentifier())?e.node.name:e?e.scope.generateUidIdentifierBasedOnNode(e.node).name:void 0}function s(e,r){switch(r){case"default":return e.isImportDefaultSpecifier();case"*":return e.isImportNamespaceSpecifier();default:return e.isImportSpecifier()&&("StringLiteral"===(t=e.node.imported).type?t.value:t.name)===r}var t}function n(e,r){return e.isImportDeclaration()&&e.get("source").node.value===r}t=r.ImportUtil=class{constructor(e,r){this.babel=e,this.program=r,this.t=e.types}removeImport(e,r){for(let t of this.program.get("body")){if(!n(t,e))continue;let o=t.get("specifiers").find((e=>s(e,r)));o&&(1===t.node.specifiers.length?t.remove():o.remove())}}removeAllImports(e){for(let r of this.program.get("body"))n(r,e)&&r.remove()}import(e,r,t,s){return this.unreferencedImport(e,r,t,o(s,t,i(e)))}unreferencedImport(e,r,t,o){var i;let n="*"===t,a=!("default"===t||n),l=this.findImportFrom(r),c=null==l?void 0:l.node.specifiers.find((e=>"ImportNamespaceSpecifier"===e.type));if(!((null==l?void 0:l.node.specifiers.find((e=>"ImportSpecifier"===e.type)))&&n||c&&a||c&&n)&&l){let r=l.get("specifiers").find((e=>s(e,t)));return r&&"module"===(null===(i=e.scope.getBinding(r.node.local.name))||void 0===i?void 0:i.kind)?this.t.identifier(r.node.local.name):this.addSpecifier(e,l,t,o)}{let i=this.insertAfterExistingImports(this.t.importDeclaration([],this.t.stringLiteral(r)));return this.addSpecifier(e,i,t,o)}}importForSideEffect(e){this.findImportFrom(e)||this.insertAfterExistingImports(this.t.importDeclaration([],this.t.stringLiteral(e)))}replaceWith(e,r){return this.mutate((t=>(e.replaceWith(r(t)),e)),i(e))}insertAfter(e,r){return this.mutate((t=>e.insertAfter(r(t))[0]),i(e))}insertBefore(e,r){return this.mutate((t=>e.insertBefore(r(t))[0]),i(e))}mutate(e,r){let t=new Map;const i=e=>{if(!e.isIdentifier())return;let i=t.get(e.node);if(i){let t=this.unreferencedImport(e,i.moduleSpecifier,i.exportedName,o(i.nameHint,i.exportedName,r));e.replaceWith(t);let s=e.scope.getBinding(t.name);if(!s)throw new Error("bug: this is supposed to never happen");s.reference(e)}};let s=e({import:(e,r,o)=>{let i=this.t.identifier("__babel_import_util_placeholder__");return t.set(i,{moduleSpecifier:e,exportedName:r,nameHint:o}),i}});return i(s),this.babel.traverse(s.node,{ReferencedIdentifier:e=>{i(e)}},s.scope,{},s),s}addSpecifier(e,r,t,o){let i,s=this.t.identifier(function(e,r){let t=r,o=0;for(;e.scope.hasBinding(t);)t=`${r}${o++}`;return t}(e,o)),n=this.buildSpecifier(t,s);return"ImportDefaultSpecifier"===n.type?(r.node.specifiers.unshift(n),i=r.get("specifiers.0")):(r.node.specifiers.push(n),i=r.get("specifiers."+(r.node.specifiers.length-1))),r.scope.registerBinding("module",i),s}buildSpecifier(e,r){switch(e){case"default":return this.t.importDefaultSpecifier(r);case"*":return this.t.importNamespaceSpecifier(r);default:return this.t.importSpecifier(r,this.t.identifier(e))}}findImportFrom(e){for(let r of this.program.get("body"))if(r.isImportDeclaration()&&r.node.source.value===e&&"type"!==r.node.importKind)return r}insertAfterExistingImports(e){let r;for(let[t,o]of this.program.node.body.entries())"ImportDeclaration"===o.type&&(r=t);return null==r?(this.program.node.body.unshift(e),this.program.get("body.0")):(this.program.node.body.splice(r+1,0,e),this.program.get(`body.${r+1}`))}};var a={},l={};Object.defineProperty(l,"__esModule",{value:!0}),l.declare=p,l.declarePreset=void 0;const c={assertVersion:e=>r=>{!function(e,r){if("number"==typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`}if("string"!=typeof e)throw new Error("Expected string or integer value.");const t=Error.stackTraceLimit;let o;throw"number"==typeof t&&t<25&&(Error.stackTraceLimit=25),o="7."===r.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${r}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${e}", but was loaded with "${r}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`),"number"==typeof t&&(Error.stackTraceLimit=t),Object.assign(o,{code:"BABEL_VERSION_UNSUPPORTED",version:r,range:e})}(r,e.version)}};function p(e){return(r,t,o)=>{var i;let s;for(const e of Object.keys(c))r[e]||(null!=s||(s=u(r)),s[e]=c[e](s));return e(null!=(i=s)?i:r,t||{},o)}}Object.assign(c,{targets:()=>()=>({}),assumption:()=>()=>{}});const d=p;function u(e){let r=null;return"string"==typeof e.version&&/^7\./.test(e.version)&&(r=Object.getPrototypeOf(e),!r||f(r,"version")&&f(r,"transform")&&f(r,"template")&&f(r,"types")||(r=null)),Object.assign({},r,e)}function f(e,r){return Object.prototype.hasOwnProperty.call(e,r)}l.declarePreset=d,Object.defineProperty(a,"__esModule",{value:!0});var m=a.default=void 0,h=l;function g(r){const o=r.types;return{Program(i,s){s.currentClassBodies=[],s.currentObjectExpressions=[],s.optsWithDefaults={runtime:"globals",runEarly:!1,...s.opts},s.util=new t(r,i),s.runtime=(r,t)=>{const{runtime:i}=s.optsWithDefaults;return"globals"===i?o.memberExpression(o.identifier(e),o.identifier(t)):r.import(i.import,t)}},ClassBody:{enter(e,r){r.currentClassBodies.unshift(e.node)},exit(e,r){r.currentClassBodies[0]===e.node&&r.currentClassBodies.shift()}},ClassExpression(e,r){let t=e.get("decorators");Array.isArray(t)&&t.length>0&&r.util.replaceWith(e,(i=>{let s=o.callExpression(r.runtime(i,"c"),[e.node,o.arrayExpression(t.slice().reverse().map((e=>e.node.expression)))]);for(let e of t)e.remove();return s}))},ClassDeclaration(e,r){let t=e.get("decorators");if(Array.isArray(t)&&t.length>0){const i=i=>o.callExpression(r.runtime(i,"c"),[o.classExpression(e.node.id,e.node.superClass,e.node.body,[]),o.arrayExpression(t.slice().reverse().map((e=>e.node.expression)))]);if(e.parentPath.isExportDefaultDeclaration()){let t=e.node.id;t?(r.util.insertBefore(e.parentPath,(e=>o.variableDeclaration("const",[o.variableDeclarator(t,i(e))]))),e.parentPath.replaceWith(o.exportDefaultDeclaration(t))):r.util.replaceWith(e.parentPath,(e=>o.exportDefaultDeclaration(i(e))))}else if(e.parentPath.isExportNamedDeclaration()){let t=e.node.id;if(!t)throw new Error("bug: expected a class name is required in this context");r.util.insertBefore(e.parentPath,(e=>o.variableDeclaration("const",[o.variableDeclarator(t,i(e))]))),e.parentPath.replaceWith(o.exportNamedDeclaration(null,[o.exportSpecifier(t,t)]))}else{let t=e.node.id;if(!t)throw new Error("bug: expected a class name is required in this context");r.util.replaceWith(e,(e=>o.variableDeclaration("const",[o.variableDeclarator(t,i(e))])))}}},ClassProperty(e,r){let t=e.get("decorators");if(Array.isArray(t)&&t.length>0){let i;i=e.node.static?o.thisExpression():o.memberExpression(o.thisExpression(),o.identifier("prototype"));let s=[i,b(o,e.node.key),o.arrayExpression(t.slice().reverse().map((e=>e.node.expression)))];e.node.value&&s.push(o.functionExpression(null,[],o.blockStatement([o.returnStatement(e.node.value)]))),r.util.insertBefore(e,(e=>o.staticBlock([o.expressionStatement(o.callExpression(r.runtime(e,"g"),s))]))),r.util.insertBefore(e,(t=>{return o.classPrivateProperty(o.privateName(o.identifier(function(e,r){let t=e.currentClassBodies[0];if(!t)throw new Error("bug: no current class body around our class field decorator");let o=new Set;for(let s of t.body)"ClassPrivateProperty"!==s.type&&"ClassPrivateMethod"!==s.type&&"ClassAccessorProperty"!==s.type||"PrivateName"!==s.key.type||o.add(s.key.id.name);let i=r;for(;o.has(i);)i+="_";return i}(r,"Identifier"===(i=e.node.key).type?i.name:"BigIntLiteral"===i.type||"NumericLiteral"===i.type?`_${i.value}`:"StringLiteral"===i.type?"_"+i.value.replace(/[^a-zA-Z]/g,""):"_"))),o.sequenceExpression([o.callExpression(r.runtime(t,"i"),[o.thisExpression(),b(o,e.node.key)]),o.identifier("void 0")]));var i})),e.remove()}},ClassMethod(e,r){let t=e.get("decorators");if(Array.isArray(t)&&t.length>0){let i;i=e.node.static?o.thisExpression():o.memberExpression(o.thisExpression(),o.identifier("prototype")),r.util.insertAfter(e,(s=>o.staticBlock([o.expressionStatement(o.callExpression(r.runtime(s,"n"),[i,b(o,e.node.key),o.arrayExpression(t.slice().reverse().map((e=>e.node.expression)))]))])));for(let e of t)e.remove()}},ObjectExpression:{enter(e,r){r.currentObjectExpressions.unshift({node:e.node,decorated:[]})},exit(e,r){var t;if((null==(t=r.currentObjectExpressions[0])?void 0:t.node)!==e.node)return;let{decorated:i}=r.currentObjectExpressions.shift();i.length>0&&r.util.replaceWith(e,(t=>o.callExpression(r.runtime(t,"p"),[e.node,o.arrayExpression(i.map((([e,r,t])=>o.arrayExpression([o.stringLiteral(e),r,o.arrayExpression(t)]))))])))}},ObjectProperty(e,r){let t=e.get("decorators");if(Array.isArray(t)&&t.length>0){if(0===r.currentObjectExpressions.length)throw new Error("bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression");let i=e.node.key;if("PrivateName"===i.type)throw new Error("cannot decorate private field");r.currentObjectExpressions[0].decorated.push(["field",b(o,i),t.slice().reverse().map((e=>e.node.expression))]);for(let e of t)e.remove()}},ObjectMethod(e,r){let t=e.get("decorators");if(Array.isArray(t)&&t.length>0){if(0===r.currentObjectExpressions.length)throw new Error("bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression");let i=e.node.key;r.currentObjectExpressions[0].decorated.push(["method",b(o,i),t.slice().reverse().map((e=>e.node.expression))]);for(let e of t)e.remove()}}}}function y(e){let r=g(e);return{inherits:(e,r,t)=>m(e,{legacy:!0},t),pre(t){this.opts.runEarly&&(e.traverse(t.ast,g(e),t.scope,this),r=void 0)},get visitor(){return r??{}}}}function b(e,r){return"Identifier"===r.type?e.stringLiteral(r.name):r}m=a.default=(0,h.declare)(((e,r)=>{e.assertVersion(7);let{version:t}=r;{const{legacy:e}=r;if(void 0!==e){if("boolean"!=typeof e)throw new Error(".legacy must be a boolean.");if(void 0!==t)throw new Error("You can either use the .legacy or the .version option, not both.")}if(void 0===t)t=e?"legacy":"2018-09";else if("2023-05"!==t&&"2023-01"!==t&&"2022-03"!==t&&"2021-12"!==t&&"2018-09"!==t&&"legacy"!==t)throw new Error("Unsupported decorators version: "+t);var{decoratorsBeforeExport:o}=r;if(void 0===o){if("2021-12"===t||"2022-03"===t)o=!1;else if("2018-09"===t)throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.")}else{if("legacy"===t||"2022-03"===t||"2023-01"===t)throw new Error(`'decoratorsBeforeExport' can't be used with ${t} decorators.`);if("boolean"!=typeof o)throw new Error("'decoratorsBeforeExport' must be a boolean.")}}return{name:"syntax-decorators",manipulateOptions({generatorOpts:e},r){"legacy"===t?r.plugins.push("decorators-legacy"):"2023-01"===t||"2023-05"===t?r.plugins.push(["decorators",{allowCallParenthesized:!1}],"decoratorAutoAccessors"):"2022-03"===t?r.plugins.push(["decorators",{decoratorsBeforeExport:!1,allowCallParenthesized:!1}],"decoratorAutoAccessors"):"2021-12"===t?(r.plugins.push(["decorators",{decoratorsBeforeExport:o}],"decoratorAutoAccessors"),e.decoratorsBeforeExport=o):"2018-09"===t&&(r.plugins.push(["decorators",{decoratorsBeforeExport:o}]),e.decoratorsBeforeExport=o)}}}));export{y as default};
